# 어플리케이션(Applications)

기본적으로, 이더리움을 이용하여 총 세 가지 카테고리의 어플리케이션을 제작할 수 있다. 
첫번째 카테고리는 돈과 직접적으로 연관된 컨트랙트를 계약참여자로 하여금 보다 강력하게 설정-관리하게끔 하는 금융 어플리케이션이다. 
이의 예는 하위화폐(=유로/달러 등의 상위화폐와 환율이 연동된 화폐를 지칭), 파생상품, 헷지컨트랙트, 예금용 전자지갑, 유언장, 
그리고 최종적으로는 전면적인 고용계약 수준의 것들까지 포함한다. 
두번째 카테고리는 준(準)금융 어플리케이션이다. 금전이 관여되어 있지만, 상당부분 비(非)화폐적인 면이 존재하는 계약을 위한 어플리케이션이 이에 해당된다. 
이의 좋은 예로는 어려운 연산 문제를 푸는 자에게 자동적으로 포상금이 지급되는 계약이다. 
마지막으로, 온라인 투표와 분권형(分權形) 거버넌스(Governance)와 같이 금융과 관련성이 아예 없는 어플리케이션이 있다.






# 토큰 시스템(Token Systems)
블록체인토큰시스템(On-blockchain token system)은 미화/금 등과 연동된 하위화폐, 
주식과 “스마트자산* (Smart Property: 비트코인의 블록체인 상에서 소유권이 컨트롤/관리되는 자산),” "위조불가능한(secure unforgeable)" 쿠폰, 
그리고 통상적인 가치와 연결되어 있지 않은 기타 토큰시스템 (예, 인센티브 부여를 위한 포인트제도) 등에 이르기까지 다양한 형태의 거래시스템을 네트워크 상에서 구현하게끔 해주는 어플리케이션들을 갖고 있다. 
이더리움에서 토큰시스템은 놀랍도록 쉽게 구현할 수 있다. 토큰시스템을 이해하는 데에 핵심은 아래와 같다.

모든 화폐 혹은 토큰시스템은 근본은 결국 한 가지 오퍼레이션만을 수행하는 데이터베이스이다.
A라는 주체로부터 X 단위의 화폐/토큰을 차감하고, 차감한 X 단위의 화폐/토큰을 B에게 지급한다. 단, 거래 전, A는 최소 X단위를 보유하고 있었음
A가 이 거래를 승인함
이더리움에서 유저는 바로 위의 로직을 컨트랙트에 반영 시키기만 하면 된다. Serpent 에서 토큰시스템을 실행하는 기본적은 코드는 아래와 같다:

def send(to, value):
    if self.storage[msg.sender] >= value:
        self.storage[msg.sender] = self.storage[msg.sender] - value
        self.storage[to] = self.storage[to] + value
이는 기본적으로 본 백서에서 설명한 “은행시스템”의 "상태변환함수(state transition function)"를 아무런 가공없이 그대로적용시킨 것이다. 
통화의 단위를 정의하고 배급하기 위한 최초 작업을 위해서, 또는 더 나아가 여타 컨트랙트들이 계좌의 잔금에 대한 정보요청을 처리하기 위한, 몇 줄의 코드가 추가적으로 더 쓰여져야 할 수도 있다. 
하지만, 그 정도가 토큰시스템을 만드는 데 필요한 전부이다. 이론적으로, 
이더리움에 기반한 하위화폐 체계로서의 토큰시스템은 비트코인에 기반한 메타화폐 (=비트코인 블록체인 연동된 화폐)가 갖고 있지 않는 중요한 특성을 지니고 있을 수 있다: 
거래비용을 거래 시 사용한 화폐로 직접 지불할 수 있다는 점이 그것이다. 다음과 같은 과정을 통하여 이 특성은 발현될 수 있다: 
컨트랙트을 집행하기 위해서는 발송인에게 지불해야 하는 비용 만큼의 이더 잔고를 유지해야 한다. 
그리고 컨트랙트 집행 시 수수료로 받는 내부화폐(하위화폐)를 (상시 돌아가고 있는 내부화폐-이더 거래소에서) 즉각 환전하여 이더 잔고로 충전할 수 있다. 
유저들은 그렇게 이더로 그들의 계좌들을 “활성화”시켜야 하지만 각 컨트랙트를 통해 얻어지는 만큼의 금액을 이더로 매번 환전해 주기에, 한 번 충전된 이더는 재사용이 가능하다고 볼 수 있다.





# 파생상품과 가치안정통화
파생상품은 “스마트 컨트랙트”의 가장 일반적인 어플리케이션이며, 코드로 실행할 수 있는 가장 간단한 형태의 어플리케이션 중 하나다. 
금융 컨트랙트를 실행하는 데 가장 주된 어려움은 대부분의 경우 계약에서 규정하는 자산에 대한 시세를 외부에서 참조해야 한다는 것이다. 
예를 들어, 금융컨트랙트에 매우 필요한 것은 이더(또는 기타 가상화폐)-USD 변동성에 대해 헷지(hedge)하는 어플리케이션인데, 
이 헷지컨트랙트를 실행하기 위해서는 ETH/USD의 환율을 제공할 수 있는 컨트랙트가 필요하다. 
환율을 알기 위한 가장 쉬운 방법은 주식시장의 NASDAQ과 같은 특정한 제 3자가 실시간으로 제공하는 “데이터피드” 컨트랙트를 통해서이고, 관여주체는 필요할 때 마다 환율을 업데이트할 수 있어야 하며, 
여타 컨트랙트들과 환율에 대한 메시지를 주고받을 수 있는 인터페이스를 제공할 수 있어야 한다.

상기 핵심 요건들을 가정하고, 위 언급한 헷지컨트랙트는 다음과 같은 구조를 띌 것이다:

A가 1000 이더를 입금할 때까지 기다린다
B가 1000 이더를 입금할 때까지 기다린다
입금된 이더의 달러가치를 기록하며 (환율은 Data feed 컨트랙트로 쿼리를 보냄으로써 계산한다), 이를 $X라 한다
30일 이후, 당시의 환율을 적용한 금액을 계산하여 A에게는 $X를 송금하고 당시 총금액에 나머지를 B에게 송금하도록 A 또는 B가 컨트랙트를 다시 활성화 시킬 수 있게끔 한다.
위와 같은 컨트랙트는 가상통화를 이용한 상거래의 향후 발전 가능성을 제시한다. 
가상화폐 상거래 활성화의 장애물 중 하나는 가상화폐의 높은 변동성이다; 다수의 유저들과 상인들은 가상화폐 혹은 블록체인자산이 제공하는 보안성과 편의성에 대한 니즈가 있지만, 
단 하루만의 그들의 자산가치가 23% 하락할지도 모른다는 리스크는 피하고 싶어한다. 이 문제에 대한 지금까지의 가장 보편적인 솔루션은 자산 발행자가 자산에 대한 보증을 서는 것이었다: 
이는 곧, 발행자가 하위화폐를 만들어서 그를 통해서 통화량을 조절할 수 있는 권한을 갖고, 
누군가가 일정 단위의 하위화폐를 지불하였을 때 그에 상응하는 특정한 베이스 자산 (예, USD, 금)으로 교환해주는 방식을 뜻한다. 이 방식을 본 사례에 적용한다면, 
가상화폐 발행자는 가상화폐를 지불하는 자에게 그에 상응하는 베이스자산을 제공할 것이라고 공개적인 약속을 하는 것이다. 
이 메커니즘은 비(非)가상화폐 혹은 비(非)디지털자산을 블록체인 자산화(化) 시키는 결과를 낳는다—물론 가상화폐 발행자를 신뢰할 수 있다면 말이다.

다만, 현실적으로는 자산 발행인을 언제나 신뢰를 할 수 없으며, 몇몇 사례를 보면, 우리의 금융인프라는 자산보증 서비스가 존재하기에는 너무 취약하거나, 때로는 적대적이기도 하다. 
파생상품은 이에 대한 대안을 제공해준다. 
여기서 자산을 보증하기 위한 펀드를 제공하는 역활을 하나의 자산 발행자가 하는 것이 아니라 암호화 
담보자산(cryptographic reference asset, 예: 이더)의 가격이 올라갈 것이라는 데에 베팅을 하는 투자자들(speculators)의 탈중앙화된 시장이 그 역할을 담당하게 된다. 
파생상품을 통한 보증 또한 완전하게 탈중앙화된 방법론은 아니라는 것을 주의하기 바란다. 비록 자산 발행자을 통한 방법 보다 진입장벽(영업허가증 등이 필요 없음)이 없고 사기/조작 가능성이 줄어들기는 하지만, 
신뢰성있는 제 3기관이 USD/ETH 시세 또는 환율을 제공해야 하기 때문이다.